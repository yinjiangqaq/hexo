---
title: 解决js0.1+0.2的问题
date: 2020-04-10 11:06:51
tags: JavaScript
categories: JavaScript
---
## js为什么0.1+0.2!=0.3
因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。`number`类型中，浮点数的精度远远不如整数。浮点数的数字运算，存在的是**精度缺失**的问题，在`0.1+0.2`这个式子中，`0.1`和`0.2`都是近似表示的。

因为我们都知道计算机表示十进制使用二进制来表示的，0.1在二进制中的表示为
```
// (0011) 表示循环
0.1 = 2^-4 * 1.10011(0011)
```
如何得到这个二进制的呢，我们可以演算一下
![compute.png](解决js0-1-0-2的问题/compute.png)

小数算二进制和整数不同。乘法计算时，只计算小数位，整数位用作每一位的二进制，并且得到的第一位为最高位。所以我们得出 `0.1 = 2^-4 * 1.10011(0011)`，那么 `0.2` 的演算也基本如上所示，只需要去掉第一步乘法，所以得出 `0.2 = 2^-3 * 1.10011(0011)。`

回来继续说 IEEE 754 双精度。六十四位中符号位占一位，整数位占十一位，其余五十二位都为小数位。因为` 0.1` 和` 0.2 `都是无限循环的二进制了，所以在小数位末尾处需要判断**是否进位**（就和十进制的四舍五入一样）。

所以` 2^-4 * 1.10011...001 `进位后就变成了 `2^-4 * 1.10011(0011 * 12次)010 `。那么把这两个二进制加起来会得出 `2^-2 * 1.0011(0011 * 11次)0100 `, 这个值算成十进制就是` 0.30000000000000004`

指数不同的两个浮点数是不能直接相加的，拿
`0.2`的有效数位表达和`0.1`是相同的，但是指数部分比`0.1`的指数多1，因为恰好`0.1x2=0.2`，也可以写代码验证一下。

`0.1`的指数部分是`-4`，`0.2`指数部分是`-3`，小阶要向大阶“看齐”，0.1若要表示成指数为-3，就需要将有效数位整体右移，这样一来就能对有效数位相加

 1.100 1100 1100 1100 1100 1101` 0`

 0.110 0110 0110 0110 0110 0110 `1  `

______________________________________

10.011 0011 0011 0011 0011 0011 1

橙色部分不会因为右移而丢失，因为在计算浮点数的时候会运用两个比float位数多的临时变量来计算，double也是

规范化，四舍五入后尾数为

001 1001 1001 1001 1010

指数为-2，表达出来是 0111 1101，`0.1+0.2`的结果应该表达为

0011 1110 1001 1001 1001 1001 1001 1010（3E99 999A）


```
console.log(0.1+0.2)//0.30000000000000004
```


## 解决办法
原生的解决办法：
```
parseFloat((0.1 + 0.2).toFixed(10))
//toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。

```
ES6提供的`Number.EPSILON`方法
```

function numbersequal(a,b){ return Math.abs(a-b)<Number.EPSILON;
} 
var a=0.1+0.2， b=0.3;
console.log(numbersequal(a,b)); //true
```
